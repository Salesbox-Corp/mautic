name: Setup New Environment

on:
  workflow_dispatch:
    inputs:
      client:
        description: 'Nome do cliente'
        required: true
      environment:
        description: 'Ambiente (prod/staging/demo)'
        required: true
        default: 'prod'
      create_shared_infra:
        description: 'Criar infraestrutura compartilhada? (true/false)'
        required: true
        default: 'false'

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Backend Infrastructure
        run: |
          chmod +x scripts/bootstrap.sh
          ./scripts/bootstrap.sh

  validate:
    needs: bootstrap
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Check Required Tools
        run: |
          # Verificar se temos todas as ferramentas necessárias
          command -v mysql >/dev/null 2>&1 || { 
            echo "Instalando MySQL client..."
            sudo apt-get update && sudo apt-get install -y mysql-client
          }
          command -v jq >/dev/null 2>&1 || {
            echo "Instalando jq..."
            sudo apt-get install -y jq
          }

      - name: Validate AWS Access
        run: |
          # Obter ID da conta AWS
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="mautic-terraform-state-${AWS_ACCOUNT_ID}"
          
          echo "Verificando acesso ao S3..."
          aws s3api head-bucket --bucket $BUCKET_NAME || {
            echo "Erro: Sem acesso ao bucket do Terraform state"
            exit 1
          }
          
          echo "Verificando acesso ao DynamoDB..."
          aws dynamodb describe-table --table-name mautic-terraform-lock || {
            echo "Erro: Sem acesso à tabela de lock do Terraform"
            exit 1
          }
          
          # Verificar outros serviços
          aws secretsmanager list-secrets
          aws ssm describe-parameters
          aws rds describe-db-instances
          aws ecs list-clusters

  setup:
    needs: [bootstrap, validate]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Create Shared Infrastructure
        if: ${{ github.event.inputs.create_shared_infra == 'true' }}
        run: |
          # Obter ID da conta AWS
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="mautic-terraform-state-${AWS_ACCOUNT_ID}"

          echo "Criando infraestrutura compartilhada..."
          cd terraform/shared
          
          # Inicializar com backend configurado dinamicamente
          terraform init \
            -backend-config="bucket=${BUCKET_NAME}" \
            -backend-config="key=shared/terraform.tfstate"
          
          terraform plan -out=tfplan
          terraform apply tfplan
          
          # Verificar se RDS foi criado corretamente
          RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "Erro: RDS endpoint não encontrado"
            exit 1
          fi
          
          # Salvar credenciais no Secrets Manager
          MASTER_PASSWORD=$(terraform output -raw rds_password)
          aws secretsmanager create-secret \
            --name "/mautic/shared/rds/master" \
            --secret-string "{\"password\":\"${MASTER_PASSWORD}\"}" \
            --description "Credenciais do RDS compartilhado"

      - name: Wait for RDS Available
        run: |
          echo "Aguardando RDS ficar disponível..."
          aws rds wait db-instance-available --db-instance-identifier mautic-shared-db

      - name: Setup Client Secrets
        run: |
          echo "Configurando secrets do cliente..."
          ./scripts/manage-secrets.sh create_client_secrets ${{ github.event.inputs.client }} ${{ github.event.inputs.environment }}

      - name: Setup Client Database
        run: |
          echo "Configurando banco de dados do cliente..."
          ./scripts/manage-database.sh create_client_database ${{ github.event.inputs.client }} ${{ github.event.inputs.environment }}

      - name: Setup Client Infrastructure
        run: |
          echo "Configurando infraestrutura do cliente..."
          ./scripts/setup-client.sh ${{ github.event.inputs.client }} ${{ github.event.inputs.environment }}

      - name: Build and Push Docker Image
        env:
          ECR_REPOSITORY: mautic-${{ github.event.inputs.client }}-${{ github.event.inputs.environment }}
        run: |
          # Login no ECR
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com

          # Build com cache
          docker build \
            --cache-from $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:latest \
            -t $ECR_REPOSITORY:latest \
            -t $ECR_REPOSITORY:${{ github.sha }} \
            .

          # Push das imagens
          docker push $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:latest
          docker push $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:${{ github.sha }}

      - name: Verify Deployment
        run: |
          echo "Verificando recursos criados..."
          
          # Verificar ECS
          CLUSTER_NAME=mautic-${{ github.event.inputs.client }}-${{ github.event.inputs.environment }}-cluster
          SERVICE_NAME=mautic-${{ github.event.inputs.client }}-${{ github.event.inputs.environment }}-service
          
          # Aguardar serviço estabilizar
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME
          
          # Verificar status do serviço
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].status' \
            --output text)
          
          if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
            echo "Erro: Serviço ECS não está ativo"
            exit 1
          fi
          
          # Obter URL do ALB
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --names mautic-${{ github.event.inputs.client }}-${{ github.event.inputs.environment }}-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "Deployment concluído com sucesso!"
          echo "Application URL: http://$ALB_URL"

      - name: Notify Success
        if: success()
        run: |
          echo "Setup completo para ${{ github.event.inputs.client }}/${{ github.event.inputs.environment }}"
          # Aqui você pode adicionar notificações (Slack, Email, etc)

      - name: Notify Failure
        if: failure()
        run: |
          echo "Falha no setup de ${{ github.event.inputs.client }}/${{ github.event.inputs.environment }}"
          # Aqui você pode adicionar notificações de falha 

  cleanup_on_failure:
    if: failure()
    needs: [setup]
    runs-on: ubuntu-latest
    env:
      CLIENT: ${{ github.event.inputs.client }}
      ENVIRONMENT: ${{ github.event.inputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Cleanup Client Resources
        run: |
          echo "Limpando recursos do cliente ${CLIENT}/${ENVIRONMENT}..."
          
          # Remover recursos do cliente específico
          cd terraform/environments/clients/${CLIENT}/${ENVIRONMENT}
          terraform init \
              -backend-config="bucket=mautic-terraform-state" \
              -backend-config="key=clients/${CLIENT}/${ENVIRONMENT}/terraform.tfstate"
          terraform destroy -auto-approve || true

          # Limpar banco de dados do cliente
          RDS_CREDENTIALS=$(aws secretsmanager get-secret-value \
              --secret-id "/mautic/shared/rds/master" \
              --query 'SecretString' --output text)
          
          RDS_ENDPOINT=$(aws ssm get-parameter --name "/mautic/shared/rds/endpoint" --query "Parameter.Value" --output text)
          MASTER_USER=$(echo $RDS_CREDENTIALS | jq -r '.username')
          MASTER_PASSWORD=$(echo $RDS_CREDENTIALS | jq -r '.password')
          
          DB_NAME="mautic_${CLIENT}_${ENVIRONMENT}"
          DB_USER="${DB_NAME}_user"
          
          mysql -h $RDS_ENDPOINT -u $MASTER_USER -p${MASTER_PASSWORD} <<EOF
          DROP DATABASE IF EXISTS ${DB_NAME};
          DROP USER IF EXISTS '${DB_USER}'@'%';
          FLUSH PRIVILEGES;
          EOF

      - name: Cleanup Client Secrets and Parameters
        run: |
          # Limpar Secrets Manager específicos do cliente
          aws secretsmanager delete-secret \
            --secret-id "/mautic/${CLIENT}/${ENVIRONMENT}/credentials" \
            --force-delete-without-recovery || true

          # Limpar SSM Parameters específicos do cliente
          aws ssm delete-parameters \
            --names \
              "/mautic/${CLIENT}/${ENVIRONMENT}/config/domain" \
              "/mautic/${CLIENT}/${ENVIRONMENT}/config/email_from" \
              "/mautic/${CLIENT}/${ENVIRONMENT}/database/name" \
              "/mautic/${CLIENT}/${ENVIRONMENT}/database/user" || true

      # Cleanup da infra compartilhada APENAS se for o primeiro deploy e falhou
      - name: Cleanup Resources
        run: |
          # Obter ID da conta AWS
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="mautic-terraform-state-${AWS_ACCOUNT_ID}"

          if [[ "${{ github.event.inputs.create_shared_infra }}" == "true" ]]; then
            echo "Limpando infraestrutura compartilhada..."
            cd terraform/shared
            terraform init \
              -backend-config="bucket=${BUCKET_NAME}" \
              -backend-config="key=shared/terraform.tfstate"
            terraform destroy -auto-approve || true
          fi 